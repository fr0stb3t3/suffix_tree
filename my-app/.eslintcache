[{"D:\\Visualgos\\visualgo\\my-app\\src\\index.tsx":"1","D:\\Visualgos\\visualgo\\my-app\\src\\reportWebVitals.ts":"2","D:\\Visualgos\\visualgo\\my-app\\src\\App.tsx":"3","D:\\Visualgos\\visualgo\\my-app\\src\\Modules\\UkkonenSuffixTree_Class.ts":"4","D:\\Visualgos\\visualgo\\my-app\\src\\Modules\\UkkonenSuffixTree_Class_Stack.ts":"5"},{"size":500,"mtime":499162500000,"results":"6","hashOfConfig":"7"},{"size":425,"mtime":499162500000,"results":"8","hashOfConfig":"7"},{"size":1187,"mtime":1608962545123,"results":"9","hashOfConfig":"7"},{"size":15213,"mtime":1607432332499,"results":"10","hashOfConfig":"7"},{"size":22042,"mtime":1608990915427,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"8e2kmk",{"filePath":"15","messages":"16","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"17","messages":"18","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"19","messages":"20","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"21","usedDeprecatedRules":"22"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25"},"D:\\Visualgos\\visualgo\\my-app\\src\\index.tsx",[],["26","27"],"D:\\Visualgos\\visualgo\\my-app\\src\\reportWebVitals.ts",[],"D:\\Visualgos\\visualgo\\my-app\\src\\App.tsx",["28","29","30","31"],"D:\\Visualgos\\visualgo\\my-app\\src\\Modules\\UkkonenSuffixTree_Class.ts",["32","33"],"class TreeNode {\r\n\tarr: Array<Branch>;\r\n\ttype: string;\r\n\tlink?: TreeNode;\r\n    isRoot: boolean;\r\n    getKey: (char: string) => number;\r\n\tconstructor(getKey: (char: string) => number) {\r\n\t\tthis.arr = new Array(27);\r\n\t\tthis.type = \"internal\";\r\n        this.isRoot = false;\r\n        this.getKey = getKey;\r\n\t}\r\n\r\n\thas(character: string): [boolean, Branch?] {\r\n\t\tlet key_of_character: number = this.getKey(character);\r\n\t\tlet b: Branch = this.arr[key_of_character];\r\n\t\tif (b === undefined) {\r\n\t\t\treturn [false];\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn [true, b];\r\n\t\t}\r\n\t}\r\n\r\n\taddBranchAt(character: string, branchToAdd: Branch) {\r\n\t\tlet key_of_character: number = this.getKey(character);\r\n\t\tthis.arr[key_of_character] = branchToAdd;\r\n\t}\r\n\r\n\tgetBranch(startingBranchCharacter: string): Branch {\r\n\t\tlet key_of_character: number = this.getKey(startingBranchCharacter);\r\n\t\treturn this.arr[key_of_character];\r\n\t}\r\n}\r\n\r\nclass Leaf {\r\n\ttype: string;\r\n\tnumber: number;\r\n\tconstructor(leaf_number: number) {\r\n\t\tthis.type = \"leaf\";\r\n\t\tthis.number = leaf_number;\r\n\t}\r\n}\r\n\r\nclass Branch {\r\n\tnode?: TreeNode | Leaf;\r\n\tstart_index?: number;\r\n\tend_index_pointer?: Array<number>; //always needs to be of type Array<Int>, so it can be consistent with GLOBAL_END\r\n\r\n\tsetBranchData(_start_index: number, _end_index_pointer: Array<number>) {\r\n\t\tthis.start_index = _start_index;\r\n\t\tthis.end_index_pointer = _end_index_pointer;\r\n\t}\r\n\r\n\tincrementEndIndex() {\r\n\t\tif (this.end_index_pointer !== undefined) {\r\n\t\t\tthis.end_index_pointer![0] += 1;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthrow Error;\r\n\t\t}\r\n\t}\r\n\tgetBranchData(): [number, number] {\r\n\t\tif (this.end_index_pointer !== undefined) {\r\n\t\t\treturn [this.start_index!, this.end_index_pointer![0]];\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthrow Error;\r\n\t\t}\r\n\t}\r\n\r\n\tgetBranchDataWithPointer(): [number, number[]] {\r\n\t\treturn [this.start_index!, this.end_index_pointer!];\r\n\t}\r\n\r\n\tgetBranchDepth(): number {\r\n\t\treturn this.end_index_pointer![0] - this.start_index! + 1;\r\n\t}\r\n\r\n\tsetNode(nodeToSet: TreeNode | Leaf) {\r\n\t\tthis.node = nodeToSet;\r\n\t}\r\n}\r\n\r\n\r\n// This class tells us the location where the new character will be added\r\nclass Tuple {\r\n\tactiveNode?: TreeNode;\r\n\tstartingBranchCharacter?: string;\r\n\tdepthInBranch?: number;\r\n}\r\n\r\nclass SuffixTree {\r\n    root: TreeNode;\r\n    END: Array<number>;\r\n    text: string;\r\n\tconstructor(text: string){\r\n        this.text = text;\r\n        this.END = [-1];\r\n        \r\n        this.root = this.implicitSuffixTree(text);\r\n    }\r\n    \r\n    UPDATE_GLOBAL_END = (leaf_index: number) => { this.END[0] = leaf_index };\r\n\r\n    INCREMENT_GLOBAL_END = () => { this.END[0]++ };\r\n\r\n\tgetHead = () : TreeNode => {\r\n\t\treturn this.root;\r\n    }\r\n    \r\n    getKey = (chr: string): number => {\r\n        if (chr !== '$') {\r\n            return chr.charCodeAt(0) - 65;\r\n        }\r\n        else {\r\n            return 26;\r\n        }\r\n    }\r\n\r\n    isNextNodeReached = (branch: Branch, depthReached: number): Boolean => {\r\n\r\n        if (branch.getBranchDepth() === depthReached) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    updateActiveNode = (tuple: Tuple, j: number, arr: Array<string>) => {\r\n        if (tuple.depthInBranch! > 0) {\r\n            if (tuple.activeNode?.isRoot) {\r\n                tuple.depthInBranch! -= 1;\r\n                tuple.startingBranchCharacter = arr[j];\r\n            }\r\n    \r\n            tuple.activeNode = tuple.activeNode!.link!;\r\n            let branchBeingReferredTo = tuple.activeNode.getBranch(tuple.startingBranchCharacter!);\r\n            while (branchBeingReferredTo?.getBranchDepth() <= tuple.depthInBranch!) {\r\n                tuple.activeNode = branchBeingReferredTo.node! as TreeNode;\r\n                tuple.depthInBranch! -= branchBeingReferredTo.getBranchDepth();\r\n                if (tuple.depthInBranch === 0) {\r\n                    break;\r\n                }\r\n                else {\r\n                    j += branchBeingReferredTo.getBranchDepth();\r\n                    tuple.startingBranchCharacter = arr[j];\r\n                }\r\n                branchBeingReferredTo = tuple.activeNode.getBranch(tuple.startingBranchCharacter);\r\n            }\r\n        }\r\n        else{\r\n            tuple.activeNode = tuple.activeNode?.link!;\r\n        }\r\n    };\r\n\r\n    printTree = () => {\r\n        let rootNode = this.root;\r\n        const aux_traverse = (node: TreeNode) => {\r\n            for (let branch of node.arr) {\r\n                if (branch !== undefined) {\r\n                    console.log(`branch data for branch ${this.text[branch.start_index!]}`)\r\n                    // console.log(branch.data)\r\n                    console.log(this.text.substring(branch.start_index!, branch.end_index_pointer![0] + 1))\r\n                    if (branch.node!.type == \"leaf\") {\r\n                        console.log(\"reached leaf\")\r\n                    }\r\n                    else {\r\n                        console.log(\"diving into another node\")\r\n                        aux_traverse(branch.node! as TreeNode)\r\n                    }\r\n                }\r\n            }\r\n            console.log(\"traversed all branches for this node, going back\")\r\n        }\r\n        console.log(\"diving into root array\")\r\n        aux_traverse(rootNode)\r\n    }\r\n\r\n    implicitSuffixTree = (str: string): TreeNode => {\r\n        str = str.toUpperCase()\r\n        let arr: Array<string> = str.split(\"\")\r\n    \r\n        let root = new TreeNode(this.getKey)\r\n        root.link = root;\r\n        root.isRoot = true;\r\n    \r\n        let tuple: Tuple = new Tuple()\r\n        tuple.activeNode = root\r\n        tuple.depthInBranch = 0;\r\n    \r\n        let last_j: number = -1;\r\n        let RULE: number = 3;\r\n        let j: number;\r\n    \r\n        let current_branch: Branch = new Branch();\r\n        let current_node: TreeNode;\r\n        let current_branch_data: Array<number>;\r\n        let next_char_in_branch: string;\r\n    \r\n        let prev_node_for_suffix_link: TreeNode | undefined;\r\n    \r\n        //begin phase i\r\n        for (let i = 0; i < arr.length; i++) {\r\n            prev_node_for_suffix_link = undefined;\r\n            current_node = tuple.activeNode as TreeNode;\r\n            this.INCREMENT_GLOBAL_END() //Rapid Leaf Extension\r\n            let char_to_add: string = arr[i];\r\n    \r\n            for (j = last_j + 1; j <= i; j++) {\r\n                \r\n                if (tuple.depthInBranch === 0) { // This should, if i am correct, always correspond to a case where a branch is yet to be selected from the node \r\n                    // I wrote the above comment a few months ago and I have no idea what it means now, lmao\r\n                    // but this if statement is basically for\r\n                    // when the tuple/active point points to a node, rather than a point in the branch\r\n                    \r\n                    /* let's say in the i-th phase of j extension, you create a new internal node, (lets call it unode) which is going to be linked to another internal node, (vnode)\r\n                    now in the j+1th extension, either vnode has yet to be created or\r\n                    vnode was already created in some previous extension\r\n                    the following code takes care of the latter\r\n                    this is so because, in the case of latter, the active point (tuple) WILL ALWAYS point to a Node, rather than a place in a branch\r\n                    and it is that active node, which serves as vnode in our example.\r\n                    */\r\n                    if (prev_node_for_suffix_link !== undefined){\r\n                        prev_node_for_suffix_link.link = tuple.activeNode!;\r\n                        prev_node_for_suffix_link = undefined;\r\n                    }\r\n    \r\n                    let boolean_and_branch = tuple.activeNode.has(char_to_add); //gives [true, branch] if branch exists otherwise [false]\r\n                    \r\n                    // if the node already has a branch starting with the character we have to add, (rule 3)\r\n                    if (boolean_and_branch[0]) {\r\n                        let thisBranch: Branch = boolean_and_branch[1] as Branch;\r\n                        RULE = 3;\r\n                        tuple.depthInBranch++;\r\n                        if (this.isNextNodeReached(thisBranch, tuple.depthInBranch)) {\r\n                            /*\r\n                                this handles single character branches (example \r\n                                (root) -abbc-(node_u)- x -(node_v) - zzz... )\r\n                                so if out tuple points at node_u and the character to insert is x, then\r\n                                it checks if node_u has a branch with character x after it, therefore it points to the point right after -(node_u)-x\r\n                                but that points to a node, therefore instead of (node_u, 'x', 1) our tuple becomes (node_v, 'doesnt matter whats here, 0)\r\n                            */\r\n                            tuple.activeNode = thisBranch.node! as TreeNode;\r\n                            tuple.depthInBranch = 0; \r\n                        }\r\n                        else {\r\n                            tuple.startingBranchCharacter = char_to_add;\r\n                            current_branch = thisBranch;\r\n                        }\r\n                    }\r\n                    // else a new branch has to come out of that node (rule 2 without an internal node being created) \r\n                    else {\r\n                        RULE = 2;\r\n                        let new_branch: Branch = new Branch();\r\n                        new_branch.node = new Leaf(j);\r\n                        new_branch.setBranchData(i, this.END);\r\n                        tuple.activeNode!.addBranchAt(char_to_add, new_branch);\r\n                        current_branch = new_branch;\r\n                        tuple.startingBranchCharacter = char_to_add;\r\n                    }\r\n                }\r\n                else {\r\n                    // if our tuple / active point points to a place in the branch\r\n                    current_branch = tuple.activeNode.getBranch(tuple.startingBranchCharacter!);\r\n                    current_branch_data = current_branch.getBranchData();\r\n                    if (current_branch.getBranchDepth() > tuple.depthInBranch) {\r\n                        let index_of_next_char_in_branch: number = current_branch_data[0] + tuple.depthInBranch;\r\n                        next_char_in_branch = arr[index_of_next_char_in_branch];\r\n                        if (char_to_add === next_char_in_branch) {\r\n                            RULE = 3\r\n                            // if (current_branch.getBranchDepth() === tuple.depthInBranch) \r\n                            if (this.isNextNodeReached(current_branch, tuple.depthInBranch))\r\n                            {\r\n                                if (current_branch.node!.type === \"leaf\") {\r\n                                    // This block should never be executed either, this case should be covered by rapid leaf extension\r\n                                    RULE = 1;\r\n                                    current_branch.incrementEndIndex();\r\n                                    tuple.depthInBranch++;\r\n    \r\n                                    console.log(\"This block should never be executed either, this case should be covered by rapid leaf extension\");\r\n                                    throw new Error(\"This block should never be executed either, this case should be covered by rapid leaf extension\");\r\n                                }\r\n                                else {\r\n    \r\n                                    this.updateActiveNode(tuple, j, arr)\r\n    \r\n                                }\r\n                            }\r\n                            else {\r\n                                tuple.depthInBranch++;\r\n                            }\r\n                        }\r\n                        else {\r\n                            RULE = 2\r\n    \r\n                            // make an internal node at this spot\r\n                            let current_branch_data_with_pointer: [number, Array<number>] = current_branch.getBranchDataWithPointer();\r\n                            let internal_node: TreeNode = new TreeNode(this.getKey);\r\n                            let new_branch_with_old_data: Branch = new Branch();\r\n                            let node_of_current_branch: TreeNode | Leaf = current_branch.node as TreeNode | Leaf;\r\n    \r\n                            new_branch_with_old_data.setBranchData(index_of_next_char_in_branch, current_branch_data_with_pointer[1])\r\n                            new_branch_with_old_data.setNode(node_of_current_branch);\r\n    \r\n                            internal_node.addBranchAt(arr[index_of_next_char_in_branch], new_branch_with_old_data);\r\n                            current_branch.setNode(internal_node);\r\n                            current_branch.setBranchData(current_branch_data[0], [index_of_next_char_in_branch - 1])\r\n    \r\n                            let new_branch_with_new_data: Branch = new Branch();\r\n                            new_branch_with_new_data.setBranchData(i, this.END);\r\n                            let new_leaf_node_for_new_branch = new Leaf(j);\r\n                            new_branch_with_new_data.setNode(new_leaf_node_for_new_branch);\r\n                            internal_node.addBranchAt(char_to_add, new_branch_with_new_data);\r\n    \r\n                            //adding suffix link\r\n                            //if a new node is made right now then it means, either it is the first internal node made in the current phase \r\n                            // basically j = last_j+1 or this is not the first internal node made in the current extension (i.e an internal node was made in the previous extension of the same phase)\r\n                            // The former is already handled earlier, and the latter is handled in the following code.\r\n                            // prev_node_for_suffix_link is the previous node made in the same extension.  \r\n                            if (prev_node_for_suffix_link !== undefined){\r\n                                let prev_node: TreeNode = prev_node_for_suffix_link as TreeNode;\r\n                                prev_node.link = internal_node;\r\n                            }\r\n                            \r\n                            prev_node_for_suffix_link = internal_node;\r\n                        }\r\n                    }\r\n                    else {\r\n                        console.log(\"this shouldnt happen\");\r\n                        throw new Error(\"shouldnt happen\");\r\n                    }\r\n                }\r\n                \r\n                if (RULE === 3) {\r\n                    \r\n                    // SHOWSTOPPER\r\n                    break;\r\n                }\r\n                last_j = j;\r\n    \r\n                this.updateActiveNode(tuple, j + 1, arr)\r\n    \r\n                // current_branch = tuple.activeNode.getBranch(tuple.startingBranchCharacter!);\r\n    \r\n    \r\n            }\r\n    \r\n            if (prev_node_for_suffix_link !== undefined) {\r\n                prev_node_for_suffix_link!.link = root;\r\n            }\r\n    \r\n        }\r\n    \r\n        return root;\r\n    }\r\n}\r\n\r\nexport default SuffixTree;",["34","35"],"D:\\Visualgos\\visualgo\\my-app\\src\\Modules\\UkkonenSuffixTree_Class_Stack.ts",["36","37"],"class TreeNode {\r\n\tarr: Array<Branch>;\r\n\ttype: string;\r\n\tlink?: TreeNode;\r\n    isRoot: boolean;\r\n    getKey: (char: string) => number;\r\n\r\n    suffixLinkFrom?: TreeNode; //This tells us which node has a suffix link TO this node. Example if A --> B, theb B.suffixLinkFrom = A\r\n    // This is done for undoing a step and going back to prev step\r\n\r\n    static lastName : string | null = null;\r\n    name: string;\r\n    \r\n    // position to be displayed on html\r\n    x_pos?: number;\r\n    y_pos?: number;\r\n\r\n    //only useful when arr is an array instead of hashtable/dictionary, stores, which indics in arr have branches\r\n    // example, if this node has two branches, one from letter 'a' and from letter 'c'. Then branchesWhere = [0,2]\r\n    // doesnt need to be sorted. \r\n    branchesWhere: Array<number>;\r\n\r\n    //this constructor has a get key function to make the array branch more flexible. \r\n    // one can replace it with a hashtable/dictionary instead of using an array. \r\n    // a different getKey function will be used for that\r\n\tconstructor(getKey: (char: string) => number,) {\r\n\t\tthis.arr = new Array(27);\r\n\t\tthis.type = \"internal\";\r\n        this.isRoot = false;\r\n        \r\n        this.branchesWhere = [];\r\n\r\n        this.getKey = getKey;\r\n        this.name = this.generateName();\r\n        \r\n \r\n\t}\r\n\r\n    generateName(): string {\r\n        if (TreeNode.lastName === null){\r\n            TreeNode.lastName = '_ROOT'\r\n        }\r\n        else if (TreeNode.lastName === '_ROOT'){\r\n            TreeNode.lastName = 'A'\r\n        }\r\n        else{\r\n            let ascii_val = TreeNode.lastName.charCodeAt(TreeNode.lastName.length-1);\r\n            if (ascii_val === 'Z'.charCodeAt(0)){\r\n                TreeNode.lastName += 'A';\r\n            }\r\n            else{\r\n                let newChar = String.fromCharCode(++ascii_val);\r\n                TreeNode.lastName = TreeNode.lastName.substr(0,TreeNode.lastName.length-1) + newChar;\r\n            }\r\n        }\r\n        return TreeNode.lastName;\r\n    }\r\n\r\n\thas(character: string): [boolean, Branch?] {\r\n\t\tlet key_of_character: number = this.getKey(character);\r\n\t\tlet b: Branch = this.arr[key_of_character];\r\n\t\tif (b === undefined) {\r\n\t\t\treturn [false];\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn [true, b];\r\n\t\t}\r\n\t}\r\n\r\n\taddBranchAt(character: string, branchToAdd: Branch) {\r\n\t\tlet key_of_character: number = this.getKey(character);\r\n        this.arr[key_of_character] = branchToAdd;\r\n        \r\n        this.branchesWhere.push(key_of_character);\r\n\t}\r\n\r\n\tgetBranch(startingBranchCharacter: string): Branch {\r\n\t\tlet key_of_character: number = this.getKey(startingBranchCharacter);\r\n\t\treturn this.arr[key_of_character];\r\n\t}\r\n}\r\n\r\nclass Leaf {\r\n\ttype: string;\r\n    number: number;\r\n    \r\n    // for draw html data only\r\n    x_pos?: number;\r\n    y_pos?: number;\r\n    name: string;\r\n    //\r\n\r\n\tconstructor(leaf_number: number) {\r\n\t\tthis.type = \"leaf\";\r\n        this.number = leaf_number;\r\n        this.name = this.number.toString();\r\n\t}\r\n}\r\n\r\nclass Branch {\r\n\tnode?: TreeNode | Leaf;\r\n\tstart_index?: number;\r\n\tend_index_pointer?: Array<number>; //always needs to be of type Array<Int>, so it can be consistent with GLOBAL_END\r\n\r\n    // the name, parent_node and the contructor are irrelevant for the function of this algorithm but is vital when we need to draw it on html\r\n    name: string;\r\n    parent_node: TreeNode;\r\n    constructor(parentNode: TreeNode){\r\n        this.name = `${parentNode.name}_`;\r\n        this.parent_node = parentNode;\r\n    }\r\n\tsetBranchData(_start_index: number, _end_index_pointer: Array<number>) {\r\n\t\tthis.start_index = _start_index;\r\n        this.end_index_pointer = _end_index_pointer;\r\n        \r\n        this.name += this.start_index!.toString();\r\n\t}\r\n\r\n\tincrementEndIndex() {\r\n\t\tif (this.end_index_pointer !== undefined) {\r\n\t\t\tthis.end_index_pointer![0] += 1;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthrow Error;\r\n\t\t}\r\n\t}\r\n\tgetBranchData(): [number, number] {\r\n\t\tif (this.end_index_pointer !== undefined) {\r\n\t\t\treturn [this.start_index!, this.end_index_pointer![0]];\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthrow Error;\r\n\t\t}\r\n\t}\r\n\r\n\tgetBranchDataWithPointer(): [number, number[]] {\r\n\t\treturn [this.start_index!, this.end_index_pointer!];\r\n\t}\r\n\r\n\tgetBranchDepth(): number {\r\n\t\treturn this.end_index_pointer![0] - this.start_index! + 1;\r\n\t}\r\n\r\n\tsetNode(nodeToSet: TreeNode | Leaf) {\r\n\t\tthis.node = nodeToSet;\r\n\t}\r\n}\r\n\r\n\r\n// This class tells us the location where the new character will be added\r\nclass Tuple {\r\n\tactiveNode?: TreeNode;\r\n\tstartingBranchCharacter?: string;\r\n\tdepthInBranch?: number;\r\n}\r\n\r\n// This class will have details about a phase and extension during the construction of suffix Tree.\r\n//A collection of these classes will be used in our implicit suffix tree to get the details of the tree during each phase and its extensions\r\nclass Trace{\r\n    phase: number;\r\n    extension: number;\r\n    last_j: number;\r\n    END: number;\r\n    RULE: number;\r\n    prev_node_name: string | undefined;\r\n\r\n    activeNode: string;\r\n    activeEdge: string;\r\n    activeDepth: number;\r\n\r\n    nodeMade?: TreeNode;\r\n\r\n    constructor(phase: number, extension: number, last_j: number, END: number, RULE: number, prev_node_name: string | undefined, activePoint: Tuple){\r\n        this.phase = phase;\r\n        this.extension = extension;\r\n        this.last_j = last_j;\r\n        this.END = END;\r\n        this.RULE = RULE;\r\n        this.prev_node_name = prev_node_name;\r\n        this.activeNode = activePoint.activeNode!.name;\r\n        this.activeEdge = activePoint.startingBranchCharacter!;\r\n        this.activeDepth = activePoint.depthInBranch! as number;\r\n    }\r\n}\r\n\r\n//this class will store position for each edge and node for when I need to draw and display them on html\r\ninterface DrawData{\r\n    [id: string]: {start_x: number, start_y:number, end_x?: number, end_y?: number};\r\n}\r\n\r\n// this is basically a list of drawData() objects, one drawData object will hold info for nodes, branches for 1 extension.\r\ninterface DrawDataForPhaseExtension{\r\n    [phaseExtension: string]: DrawData;    \r\n}\r\n\r\nclass NodeRowColGrid{\r\n    \r\n}\r\n\r\nclass SuffixTree {\r\n    root: TreeNode;\r\n    END: Array<number>;\r\n    text: string;\r\n\r\n    stackTrace: Array<Trace>;\r\n    drawDataArr: DrawDataForPhaseExtension;\r\n\r\n\tconstructor(text: string){\r\n        this.text = text;\r\n        this.END = [-1];\r\n        this.stackTrace = [];\r\n        this.root = this.implicitSuffixTree(text);\r\n        this.drawDataArr = {};\r\n    }\r\n    \r\n    UPDATE_GLOBAL_END = (leaf_index: number) => { this.END[0] = leaf_index };\r\n\r\n    INCREMENT_GLOBAL_END = () => { this.END[0]++ };\r\n\r\n\tgetHead = () : TreeNode => {\r\n\t\treturn this.root;\r\n    }\r\n    \r\n    getKey = (chr: string): number => {\r\n        if (chr !== '$') {\r\n            return chr.charCodeAt(0) - 65;\r\n        }\r\n        else {\r\n            return 26;\r\n        }\r\n    }\r\n\r\n    isNextNodeReached = (branch: Branch, depthReached: number): Boolean => {\r\n\r\n        if (branch.getBranchDepth() === depthReached) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    updateActiveNode = (tuple: Tuple, j: number, arr: Array<string>) => {\r\n        if (tuple.depthInBranch! > 0) {\r\n            if (tuple.activeNode?.isRoot) {\r\n                tuple.depthInBranch! -= 1;\r\n                tuple.startingBranchCharacter = arr[j];\r\n            }\r\n    \r\n            tuple.activeNode = tuple.activeNode!.link!;\r\n            let branchBeingReferredTo = tuple.activeNode.getBranch(tuple.startingBranchCharacter!);\r\n            while (branchBeingReferredTo?.getBranchDepth() <= tuple.depthInBranch!) {\r\n                tuple.activeNode = branchBeingReferredTo.node! as TreeNode;\r\n                tuple.depthInBranch! -= branchBeingReferredTo.getBranchDepth();\r\n                if (tuple.depthInBranch === 0) {\r\n                    break;\r\n                }\r\n                else {\r\n                    j += branchBeingReferredTo.getBranchDepth();\r\n                    tuple.startingBranchCharacter = arr[j];\r\n                }\r\n                branchBeingReferredTo = tuple.activeNode.getBranch(tuple.startingBranchCharacter);\r\n            }\r\n        }\r\n        else{\r\n            tuple.activeNode = tuple.activeNode?.link!;\r\n        }\r\n    };\r\n\r\n    printTree = () => {\r\n        let rootNode = this.root;\r\n        const aux_traverse = (node: TreeNode) => {\r\n            for (let branch of node.arr) {\r\n                if (branch !== undefined) {\r\n                    console.log(`branch data for branch ${this.text[branch.start_index!]}`)\r\n                    // console.log(branch.data)\r\n                    console.log(this.text.substring(branch.start_index!, branch.end_index_pointer![0] + 1))\r\n                    if (branch.node!.type === \"leaf\") {\r\n                        console.log(\"reached leaf\")\r\n                    }\r\n                    else {\r\n                        console.log(\"diving into another node\")\r\n                        aux_traverse(branch.node! as TreeNode)\r\n                    }\r\n                }\r\n            }\r\n            console.log(\"traversed all branches for this node, going back\")\r\n        }\r\n        console.log(\"diving into root array\")\r\n        aux_traverse(rootNode)\r\n    }\r\n\r\n    outputTrace = () => {\r\n        console.table(this.stackTrace);\r\n    }\r\n\r\n    makeSuffixLink = (fromNode: TreeNode, toNode: TreeNode, drawValuesForThisExtension: DrawData | null) =>{\r\n        fromNode.link = toNode;\r\n        if (drawValuesForThisExtension){\r\n            drawValuesForThisExtension[`suffixlink_${fromNode.name}_${toNode.name}`] = {start_x: fromNode.x_pos!, start_y: fromNode.y_pos!, end_x: toNode.x_pos!, end_y: toNode.y_pos!};\r\n        }\r\n        if (!toNode.isRoot){\r\n            toNode.suffixLinkFrom = fromNode;\r\n        }\r\n    }\r\n\r\n    implicitSuffixTree = (str: string): TreeNode => {\r\n        str = str.toUpperCase()\r\n        let arr: Array<string> = str.split(\"\")\r\n    \r\n        let root = new TreeNode(this.getKey)\r\n        root.link = root;\r\n        root.isRoot = true;\r\n\r\n        //for html draw\r\n        root.x_pos = 0;\r\n        root.y_pos = 50;\r\n        //\r\n\r\n        let tuple: Tuple = new Tuple()\r\n        tuple.activeNode = root\r\n        tuple.depthInBranch = 0;\r\n    \r\n        let last_j: number = -1;\r\n        let RULE: number = 3;\r\n        let j: number;\r\n    \r\n        let current_node: TreeNode;\r\n        let current_branch: Branch;\r\n        let current_branch_data: Array<number>;\r\n        let next_char_in_branch: string;\r\n    \r\n        let prev_node_for_suffix_link: TreeNode | undefined;\r\n        \r\n        //begin phase i\r\n        for (let i = 0; i < arr.length; i++) {\r\n             \r\n            prev_node_for_suffix_link = undefined;\r\n            current_node = tuple.activeNode as TreeNode;\r\n            this.INCREMENT_GLOBAL_END() //Rapid Leaf Extension\r\n            let char_to_add: string = arr[i];\r\n    \r\n            for (j = last_j + 1; j <= i; j++) {\r\n                \r\n                let drawValuesForThisExtension: DrawData = {};\r\n                this.drawDataArr[`${i}_${j}`] = drawValuesForThisExtension;\r\n                \r\n                if (tuple.depthInBranch === 0) { // This should, if i am correct, always correspond to a case where a branch is yet to be selected from the node \r\n                    // I wrote the above comment a few months ago and I have no idea what it means now, lmao\r\n                    // but this if statement is basically for\r\n                    // when the tuple/active point points to a node, rather than a point in the branch\r\n                    \r\n                    /* let's say in the i-th phase of j extension, you create a new internal node, (lets call it unode) which is going to be linked to another internal node, (vnode)\r\n                    now in the j+1th extension, either vnode has yet to be created or\r\n                    vnode was already created in some previous extension\r\n                    the following code takes care of the latter\r\n                    this is so because, in the case of latter, the active point (tuple) WILL ALWAYS point to a Node, rather than a place in a branch\r\n                    and it is that active node, which serves as vnode in our example.\r\n                    */\r\n                    if (prev_node_for_suffix_link !== undefined){\r\n                        this.makeSuffixLink(prev_node_for_suffix_link , tuple.activeNode, drawValuesForThisExtension);\r\n\r\n                        // delete the below commented code, if everything works lel\r\n                        // prev_node_for_suffix_link.link = tuple.activeNode!;, \r\n                        prev_node_for_suffix_link = undefined;\r\n\r\n                        //draw link on html\r\n                        \r\n                    }\r\n    \r\n                    let boolean_and_branch = tuple.activeNode.has(char_to_add); //gives [true, branch] if branch exists otherwise [false]\r\n                    \r\n                    // if the node already has a branch starting with the character we have to add, (rule 3)\r\n                    if (boolean_and_branch[0]) {\r\n                        let thisBranch: Branch = boolean_and_branch[1] as Branch;\r\n                        RULE = 3;\r\n                        tuple.depthInBranch++;\r\n                        if (this.isNextNodeReached(thisBranch, tuple.depthInBranch)) {\r\n                            /*\r\n                                this handles single character branches (example \r\n                                (root) -abbc-(node_u)- x -(node_v) - zzz... )\r\n                                so if out tuple points at node_u and the character to insert is x, then\r\n                                it checks if node_u has a branch with character x after it, therefore it points to the point right after -(node_u)-x\r\n                                but that points to a node, therefore instead of (node_u, 'x', 1) our tuple becomes (node_v, 'doesnt matter whats here, 0)\r\n                            */\r\n                            tuple.activeNode = thisBranch.node! as TreeNode;\r\n                            tuple.depthInBranch = 0; \r\n                        }\r\n                        else {\r\n                            tuple.startingBranchCharacter = char_to_add;\r\n                            current_branch = thisBranch;\r\n                        }\r\n                    }\r\n                    // else a new branch has to come out of that node (rule 2 without an internal node being created) \r\n                    else {\r\n                        RULE = 2;\r\n                        let new_branch: Branch = new Branch(tuple.activeNode!);\r\n                        new_branch.node = new Leaf(j);\r\n                        new_branch.setBranchData(i, this.END);\r\n                        tuple.activeNode!.addBranchAt(char_to_add, new_branch);\r\n                        current_branch = new_branch;\r\n                        tuple.startingBranchCharacter = char_to_add;\r\n\r\n                        //draw a new node and new branch on html\r\n                        // IMP NOTE: draw NODE BEFORE BRANCH ALWAYS, because branch's position is dependant on the two nodes it connects\r\n                        // therefore the nodes need to have a definite position before its position can be used by the branch\r\n                        this.addGivenNodeToDrawData(new_branch.node, drawValuesForThisExtension);\r\n                        this.addGivenBranchToDrawData(new_branch, drawValuesForThisExtension);\r\n                    }\r\n                }\r\n                else {\r\n                    // if our tuple / active point points to a place in the branch\r\n                    current_branch = tuple.activeNode.getBranch(tuple.startingBranchCharacter!);\r\n                    current_branch_data = current_branch.getBranchData();\r\n                    if (current_branch.getBranchDepth() > tuple.depthInBranch) {\r\n                        let index_of_next_char_in_branch: number = current_branch_data[0] + tuple.depthInBranch;\r\n                        next_char_in_branch = arr[index_of_next_char_in_branch];\r\n                        if (char_to_add === next_char_in_branch) {\r\n                            RULE = 3\r\n                            // if (current_branch.getBranchDepth() === tuple.depthInBranch) \r\n                            if (this.isNextNodeReached(current_branch, tuple.depthInBranch))\r\n                            {\r\n                                if (current_branch.node!.type === \"leaf\") {\r\n                                    // This block should never be executed either, this case should be covered by rapid leaf extension\r\n                                    RULE = 1;\r\n                                    current_branch.incrementEndIndex();\r\n                                    tuple.depthInBranch++;\r\n    \r\n                                    console.log(\"This block should never be executed either, this case should be covered by rapid leaf extension\");\r\n                                    throw new Error(\"This block should never be executed either, this case should be covered by rapid leaf extension\");\r\n                                }\r\n                                else {\r\n    \r\n                                    this.updateActiveNode(tuple, j, arr)\r\n    \r\n                                }\r\n                            }\r\n                            else {\r\n                                tuple.depthInBranch++;\r\n                            }\r\n                        }\r\n                        else {\r\n                            RULE = 2\r\n    \r\n                            // make an internal node at this spot\r\n                            let current_branch_data_with_pointer: [number, Array<number>] = current_branch.getBranchDataWithPointer();\r\n                            let internal_node: TreeNode = new TreeNode(this.getKey);\r\n                            let new_branch_with_old_data: Branch = new Branch(internal_node);\r\n                            let node_of_current_branch: TreeNode | Leaf = current_branch.node as TreeNode | Leaf;\r\n    \r\n                            new_branch_with_old_data.setBranchData(index_of_next_char_in_branch, current_branch_data_with_pointer[1])\r\n                            new_branch_with_old_data.setNode(node_of_current_branch);\r\n    \r\n                            internal_node.addBranchAt(arr[index_of_next_char_in_branch], new_branch_with_old_data);\r\n                            current_branch.setNode(internal_node);\r\n                            current_branch.setBranchData(current_branch_data[0], [index_of_next_char_in_branch - 1])\r\n    \r\n                            let new_branch_with_new_data: Branch = new Branch(internal_node);\r\n                            new_branch_with_new_data.setBranchData(i, this.END);\r\n                            let new_leaf_node_for_new_branch = new Leaf(j);\r\n                            new_branch_with_new_data.setNode(new_leaf_node_for_new_branch);\r\n                            internal_node.addBranchAt(char_to_add, new_branch_with_new_data);\r\n    \r\n                            //adding suffix link\r\n                            //if a new node is made right now then it means, either it is the first internal node made in the current phase \r\n                            // basically j = last_j+1 or this is not the first internal node made in the current extension (i.e an internal node was made in the previous extension of the same phase)\r\n                            // The former is already handled earlier, and the latter is handled in the following code.\r\n                            // prev_node_for_suffix_link is the previous node made in the same extension.  \r\n                            if (prev_node_for_suffix_link !== undefined){\r\n                                let prev_node: TreeNode = prev_node_for_suffix_link as TreeNode;\r\n                                this.makeSuffixLink(prev_node, internal_node, drawValuesForThisExtension);\r\n\r\n                                // delete be;ow commented code if everything works well\r\n                                // prev_node.link = internal_node;\r\n                            }\r\n                            \r\n                            prev_node_for_suffix_link = internal_node;\r\n                        }\r\n                    }\r\n                    else {\r\n                        console.log(\"this shouldnt happen\");\r\n                        throw new Error(\"shouldnt happen\");\r\n                    }\r\n                }\r\n                \r\n                if (RULE === 3) {\r\n                    let _ = new Trace(i , j, last_j, this.END[0], RULE, prev_node_for_suffix_link?.name, tuple);\r\n                    this.stackTrace.push(_);\r\n                    // SHOWSTOPPER\r\n                    break;\r\n                }\r\n                \r\n                this.updateActiveNode(tuple, j + 1, arr)\r\n                let _ = new Trace(i , j, last_j, this.END[0], RULE, prev_node_for_suffix_link?.name, tuple);\r\n                _.nodeMade = prev_node_for_suffix_link;\r\n                this.stackTrace.push(_);\r\n                // current_branch = tuple.activeNode.getBranch(tuple.startingBranchCharacter!);\r\n                \r\n                last_j = j;\r\n    \r\n            }\r\n    \r\n            if (prev_node_for_suffix_link !== undefined) {\r\n\r\n                this.makeSuffixLink(prev_node_for_suffix_link, root, null);\r\n\r\n                //delete below commented code if nothign breaks\r\n                // prev_node_for_suffix_link!.link = root;\r\n            }\r\n    \r\n        }\r\n    \r\n        return root;\r\n    }\r\n\r\n    addGivenBranchToDrawData = (b: Branch, drawData: DrawData) => {\r\n        drawData[`branch_${b.name}`] = {start_x: b.parent_node.x_pos!, start_y: b.parent_node.y_pos!, end_x: b.node!.x_pos!, end_y: b.node!.y_pos!}\r\n    }\r\n\r\n    addGivenNodeToDrawData = (node: TreeNode | Leaf, parentNode: TreeNode, drawData: DrawData) => {\r\n        node.y_pos = parentNode.y_pos!+1;\r\n        node.x_pos =\r\n        drawData[`node_${node.name}`] = {start_x: node.x_pos!, start_y: node.y_pos!}\r\n    }\r\n\r\n}\r\n\r\nexport default SuffixTree;\r\nexport {TreeNode};",{"ruleId":"38","replacedBy":"39"},{"ruleId":"40","replacedBy":"41"},{"ruleId":"42","severity":1,"message":"43","line":2,"column":8,"nodeType":"44","messageId":"45","endLine":2,"endColumn":12},{"ruleId":"42","severity":1,"message":"46","line":4,"column":22,"nodeType":"44","messageId":"45","endLine":4,"endColumn":30},{"ruleId":"42","severity":1,"message":"47","line":9,"column":10,"nodeType":"44","messageId":"45","endLine":9,"endColumn":14},{"ruleId":"42","severity":1,"message":"48","line":9,"column":16,"nodeType":"44","messageId":"45","endLine":9,"endColumn":23},{"ruleId":"49","severity":1,"message":"50","line":166,"column":43,"nodeType":"51","messageId":"52","endLine":166,"endColumn":45},{"ruleId":"42","severity":1,"message":"53","line":207,"column":13,"nodeType":"44","messageId":"45","endLine":207,"endColumn":25},{"ruleId":"38","replacedBy":"54"},{"ruleId":"40","replacedBy":"55"},{"ruleId":"42","severity":1,"message":"56","line":196,"column":7,"nodeType":"44","messageId":"45","endLine":196,"endColumn":21},{"ruleId":"42","severity":1,"message":"53","line":339,"column":13,"nodeType":"44","messageId":"45","endLine":339,"endColumn":25},"no-native-reassign",["57"],"no-negated-in-lhs",["58"],"@typescript-eslint/no-unused-vars","'logo' is defined but never used.","Identifier","unusedVar","'TreeNode' is defined but never used.","'tree' is assigned a value but never used.","'setTree' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'current_node' is assigned a value but never used.",["57"],["58"],"'NodeRowColGrid' is defined but never used.","no-global-assign","no-unsafe-negation"]